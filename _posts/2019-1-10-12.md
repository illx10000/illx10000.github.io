---
layout: post_layout
title: brpc之container 
time: 2019年1月10日 星期四
location: 深圳
pulished: true
excerpt_separator: "brpc"
---

brpc 提供了一些容器（数据结构）用来处理业务，本文学习一下brpc的相关数据结构。    

    如文章有任何冒犯之处，例如侵权或者未标明引用，请邮件联系删除。
    本人水平有限，如有错误之处，请不吝赐教。

# 1. BoundedQueue 有限队列

brpc使用了一个数组维护了一个有限队列，非线程安全；

BoundedQueue大量使用了placement new的方式，避免内存的分配和构造，看一个例子：

```c++
void elim_push(const T& item) {
    if (_count < _cap) { //内存足够
        new ((T*)_items + _mod(_start + _count, _cap)) T(item);
        ++_count;
    } else { //内存不够
        ((T*)_items)[_start] = item;
        _start = _mod(_start + 1, _cap);//防止到最前面
    }
}
```
内存足够，直接拷贝到最新的位置，数组位置是 ***(_start+_count)%_cap***，否则放置到最前面，使用了取模和两个游标方式，很巧妙；

# 2. flatmap 

flatmap是一个hashmap，官方文档说的很清楚：[https://github.com/brpc/brpc/blob/master/docs/cn/flatmap.md](https://github.com/brpc/brpc/blob/master/docs/cn/flatmap.md)


flatmap实现为一个模板类，可以穿入5个模板参数，看定义；
```c++
template <typename _K, typename _T,
          typename _Hash = DefaultHasher<_K>,
          typename _Equal = DefaultEqualTo<_K>,
          bool _Sparse = false>
```
其中 _K,_T分别是key和value的类型，_Hash，_Equal 分别是hash和比较的仿函数，_Sparse指定是否为稀疏map，如果是稀疏map，则使用bitmap对key进行管理；


# 2.1 flatmap操作符 operator[]实现
代码在 flat_map_ini.h 中；

```c++
template <typename _K, typename _T, typename _H, typename _E, bool _S>
_T& FlatMap<_K, _T, _H, _E, _S>::operator[](const key_type& key) {
```


1. 先对key进行Hash，然后取模桶数；
2. 判断取到的桶的第一个元素是否合法（默认创建的桶是非法的，可以使用），如果为空，则说明key无值，使用placement new创建值，并且返回；
3. 如果桶已经有值，则判断第一个元素的hash值是否和key一致，如果是，直接返回value;
4. 判断first element的next指针是否有值，如果没有值，放入该位置（需要判断拥塞）；
5. 循环链表，找到一个element的next指针为空，加入进去；


# 3. 双缓冲数据 DoublyBufferedData

官方参考资料：[https://github.com/brpc/brpc/blob/master/docs/cn/lalb.md](https://github.com/brpc/brpc/blob/master/docs/cn/lalb.md)


DoublyBufferedData 通过读者优先的方式，



