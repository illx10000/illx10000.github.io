---
layout: post_layout
title:  cache淘汰策略
time: 2019年5月23日 星期四
location: 深圳
pulished: true
excerpt_separator: "cache"
---

cache通常用来缓存热点数据，用于加速访问等；
业务这边有一些防重放的需求，简单学习一些cache淘汰策略的需求

<!-- TOC -->

- [lru](#lru)
    - [lru原理](#lru原理)
    - [lru c++ 实现](#lru-c-实现)
- [lru-k](#lru-k)
    - [lru-k原理](#lru-k原理)
    - [lru-k c++实现](#lru-k-c实现)

<!-- /TOC -->


#lru

## lru原理
[lru(least recentl used)](https://songlee24.github.io/2015/05/10/design-LRU-Cache/)最近最久未使用，将最近最久没有使用的数据淘汰。这种cache算法基于这样一种思路：最近访问过的数据，在接下来也有可能会被访问；

从实现来看：将所有数据放入链表，有访问过的数据，放入链表的头部，当链表的容量超过限制的时候，淘汰链表尾部的数据；

## lru c++ 实现

通常在c++实现中，使用[std::list](http://www.cplusplus.com/reference/list/list/) 和[unordered_map](https://zh.cppreference.com/w/cpp/header/unordered_map)


参考例子：[https://github.com/illx10000/relax/blob/master/leetcode-cn/0146.cpp](https://github.com/illx10000/relax/blob/master/leetcode-cn/0146.cpp)

# lru-k
当有周期性的批量存取消息在lru 缓存中，cache会被污染，命中率下降，因此引入LRU-K的方式应对缓存污染

## lru-k原理

LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。

## lru-k c++实现

通常lru-k实现，会有两条队列，高优先级队列和低优先级队列，